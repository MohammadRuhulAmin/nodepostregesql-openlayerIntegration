<!doctype html>
<html lang="en">
  <head>
    <!-- bootstrap start  -->
   
    <script src='https://kit.fontawesome.com/a076d05399.js' crossorigin='anonymous'></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css">
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.1/dist/jquery.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
    <!-- bootstrap end  -->

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.5.0/css/ol.css" type="text/css">
    <link rel="stylesheet" href="css/style.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.6.2/proj4.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.5.0/build/ol.js"></script>
    <script src="https://unpkg.com/@turf/turf@5.1.6/turf.min.js"></script>
  </head>
  <body>
 
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        
        
      <form action="/" method="get">
        <button type="submit"> Home </button>
      </form>
      <button type="submit" id="parentChildCombineGeoJson" onclick="combinParentChildPlotDisplay()" class="btn btn-primary m-1" data-toggle="modal" data-target="#exampleModalCenter">
         Parent & Child Combine
      </button>
      <div class="collapse navbar-collapse" id="navbarNav">
        <h2> &nbsp; &nbsp; Mutation: Map Splitting Demo </h2>

      </div>
      
      <button class="btn btn-success" id="type" onclick="typeSelectFunction();typeSelectOnChange()"><b>/</b></button> 
    
      <div class="btn-group" role="group" aria-label="Basic example">
        <button type="button" id="cutButton" class="btn btn-success m-1" onclick="splitOperationWithTurf();DisplaySplitPoly1();DisplaySplitPoly2();buttonEnableDisable();displayCutMessage()" > Split </button>
        <button type="button" class="btn btn-success btn-sm" data-toggle="modal" data-target="#Adjust">
          Adjust 
       </button>
        <button type="button" class="btn btn-warning m-1" data-toggle="modal" onclick="map_sp_3Div();" data-target="#NequalSplitPolygon"> Equal Split  </button>
        <!-- <button type="button" class="btn btn-success m-1" onclick="DisplaySplitPoly1()"> Plot 1 </button>
        <button type="button" class="btn btn-success m-1" onclick="DisplaySplitPoly2()"> Plot 2</button> -->
        <button type="button" class="btn btn-primary m-1" onclick="clearPage()"> Reset </button>
        <button type="button" class="btn btn-primary m-1 btn-sm" onclick="lineCoordinatesLabeling()">Line Label </button>
        <button id = "saveButton" type="button" class="btn btn-primary btn-sm" data-toggle="modal" data-target="#confirmSave">
          Save 
        </button>

       <!-- <form action="/saveEqualSplitedPolygon" method="post">
          <input type="hidden" id="NSplittedGeoJsons" value="xxxxx" name="NSplittedGeoJsons" />
          <button type="submit" class="btn btn-danger m-1 btn-small">Save_ES</button>
        </form>   -->
      
      </div>
    </nav>
    <ul class="list-group list-group-horizontal m-2">
      <li class="list-group-item">District : <%=district %></li>
      <li class="list-group-item">Sub District : <%=subDistrict %></li>
      <li class="list-group-item">JL No : <%=jlNo %></li>
      <li class="list-group-item">Plot No : <%=plotNo %></li>
      <% if (locals.parent_plot) { %>
        <!-- <li class="list-group-item">Parent Plot :<%=parent_plot %></li> -->
        <li class="list-group-item"> <a href="<%=link %>">Parent Plot: <%=parent_plot %></a> </li>
      <% } %>
    </ul>
    <ul class="list-group list-group-horizontal m-2">
      <li class="list-group-item">Shape Area : <%=(parseFloat(plotArea)*0.00002295684113).toFixed(2)  %> acre</li>
      <li class="list-group-item">Shape Length : <%=(parseFloat(plotLeng)*3.28084).toFixed(2)  %> ft</li>
      <li class="list-group-item"> <span id="area1"></span> <span id="sA_1"></li>
      <li class="list-group-item"><span id="area2"></span> <span id="sA_2"></li>
    </ul>
    <div id="map" class="map"></div>
    <input type="hidden" id="combineGeoJson" value="<%=combineGeoJson %>" />
    <input id="plotInfo" type="hidden" value="<%=plotInfo %>"/>
    <input type="hidden" id="plotTotalArea" value="<%=plotArea %>" />
    <div class="modal fade" id="exampleModalCenter" tabindex="-1" role="dialog" aria-labelledby="exampleModalCenterTitle" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <h6 class="modal-title" id="exampleModalLongTitle">Parent & Child Combine Plot   </h6>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span aria-hidden="true">&times;</span>
            </button>
          </div>
          <div class="modal-body">
            <div class="map" id="parentChildCombine"></div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>
    <!-- modal end  -->
    <div class="row m-3">
     
      <div id="map_sp_1" class="map2 m-1 container col-lg">
        <p ><badge id="a1"></badge> <badge id="area_sp_1"></badge></p>
      </div>
      <div id="map_sp_2" class="map2 m-1 container col-lg">
        <p > <badge id="a2"></badge> <badge id="area_sp_2"></badge></p>
      </div>
    </div>
    <div id="map_sp_3" class="map3">
      
    </div>
   

    <!-- script for display parent plot  -->
   <script type="text/javascript">
      var childPlotArea1,childPlotArea2;
      //const utm = "+proj=cass";
      const utm = "+proj=utm +zone=32";
      const wgs84 = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs";
      document.getElementById('map_sp_3').hidden = true;
      const source = new ol.source.Vector({wrapX: false});
      const vector_string = new ol.layer.Vector({
            source:source,
            style: new ol.style.Style({
              fill: new ol.style.Fill({
                color: 'rgba(255, 255, 255, 0.9)'
              }),
              stroke: new ol.style.Stroke({
                color: 'red',
                width: 1
              })
            })
        });
      const plotGeo =  document.getElementById("plotInfo").value;
      var map = new ol.Map({
            target: 'map',
            layers: [
                vector_string,
                new ol.layer.Graticule({
                // the style to use for the lines, optional.
                visible: true,
                strokeStyle: new ol.style.Stroke({
                  color: 'rgba(255,120,0,0.9)',
                  width: 1,
                  lineDash: [10,10],
                }),
                showLabels: true ,
                wrapX: false ,
              }),
                
                
            ],
            view: new ol.View(),
        
        });
      
      var geometry = new ol.format.GeoJSON().readGeometry(plotGeo);
      function removeLastVectorString(){
        var features_lineString = vector_string.getSource().getFeatures();
        features_lineString.forEach((feature) => {
          vector_string.getSource().removeFeature(feature);
         });
      }
      map.addLayer(
        new ol.layer.Vector({
          source: new ol.source.Vector({
            features: [new ol.Feature(geometry)]
          }),
          style: new ol.style.Style({
              stroke: new ol.style.Stroke({
                color: 'black',
                width: 1,
                opacity: 0.25
              })
            })
         
        })
      );
    

      map.getView().fit(geometry);
     
   </script>

   <!-- labeling for parent plot  -->
   <script>
      
      var vector_sp_1;
      var data = JSON.parse(plotGeo)
       // getting distance 
      var coordinateDistance_parent = [];
      var coordinateDistance_sp_plot_1 = [];
      var coordinateDistance_sp_plot_2 = [];
      var parentCoordinatesLangLot = [];
      function parentCoordinateLangLotConverter(){
          for(let i = 0;i<data.coordinates[0][0].length;i++){
             const coord = proj4(utm,wgs84,[data.coordinates[0][0][i][0],data.coordinates[0][0][i][1]])
             parentCoordinatesLangLot.push(coord);
          }
      }
      parentCoordinateLangLotConverter();
      
      function designDistance(data,coordinateDistance){
        const length = parentCoordinatesLangLot.length;
          for(let i = 1;i<length;i++){
              var dist = distance(parentCoordinatesLangLot[i-1][0],parentCoordinatesLangLot[i][0],parentCoordinatesLangLot[i-1][1],parentCoordinatesLangLot[i][1]);
              coordinateDistance.push(dist);
          }
          coordinateDistance.push(distance(parentCoordinatesLangLot[length-1][0],parentCoordinatesLangLot[0][0],parentCoordinatesLangLot[length-1][1],parentCoordinatesLangLot[0][1]));
        }
      designDistance(data,coordinateDistance_parent);
      // distance of coordinates 
      function distance(lat1,lat2, lon1, lon2){
        lon1 =  lon1 * Math.PI / 180;
        lon2 = lon2 * Math.PI / 180;
        lat1 = lat1 * Math.PI / 180;
        lat2 = lat2 * Math.PI / 180;
        let dlon = lon2 - lon1;
        let dlat = lat2 - lat1;
        let a = Math.pow(Math.sin(dlat / 2), 2)
                 + Math.cos(lat1) * Math.cos(lat2)
                 * Math.pow(Math.sin(dlon / 2),2);
               
        let c = 2 * Math.asin(Math.sqrt(a));
        let r = 6371;
        let sln = c*r;
        return(c * r * 1000* 3.28084 );
    }
 
      // mid point of coordinates 
      const midPointArray_parent = [];
     

      function midPointOfCoordinates(data,midPointArray){
        let coord = data.coordinates[0][0];
        for(let i = 1;i<coord.length;i++){
          let midx = (coord[i-1][0] + coord[i][0])/2;
          let midy = (coord[i-1][1] + coord[i][1])/2;
          midPointArray.push([midx,midy]);
        }
        midPointArray.push([(coord[0][0] + coord[coord.length - 1][0])/2,(coord[0][1] + coord[coord.length-1][1])/2]);
      }
      midPointOfCoordinates(data,midPointArray_parent);
      
      // function to add label : 
      function displayLabelForParentPlot(coordx,coordy,distance){
            const labelFeature = new ol.Feature({
                geometry: new ol.geom.Point([coordx,coordy]),
            });
            const labelonly = new ol.style.Style({
                text: new ol.style.Text({
                    font: '10px sans-serif',
                    text:`${distance.toFixed(1)} ft`,
                    fill: new ol.style.Fill({
                        color: 'red'
                    }),
                    
                })
             
            });

            labelFeature.setStyle(labelonly);
            const vectorSource_for_parent_label = new ol.source.Vector({
                features: [labelFeature]
            });
            map.addLayer(
                new ol.layer.Vector({
                    source: vectorSource_for_parent_label
                })
            );
        }
      function StyleCoordinatesOnParentPlot(coordx,coordy){
        const labelFeature = new ol.Feature({
                geometry: new ol.geom.Point([coordx,coordy]),
            });
            const labelonly = new ol.style.Style({
              image: new ol.style.Circle({
                        radius: 6,
                        stroke: new ol.style.Stroke({
                        color: 'rgba(0,0, 255, 1)',
                  }),
                }),
              });
            labelFeature.setStyle(labelonly);
            const vectorSource_for_parent_label = new ol.source.Vector({
                features: [labelFeature]
            });
            map.addLayer(
                new ol.layer.Vector({
                    source: vectorSource_for_parent_label
                })
            );
      }
      var parentVartex = data.coordinates[0][0];
       for(let i = 0;i<parentVartex.length;i++){
          StyleCoordinatesOnParentPlot(parentVartex[i][0],parentVartex[i][1]);
       }
      //end 
      //  function displayOnClickParentPlot(){
        for(let i = 0;i<midPointArray_parent.length;i++){
          if(coordinateDistance_parent[i]>0){
            displayLabelForParentPlot(midPointArray_parent[i][0],midPointArray_parent[i][1], coordinateDistance_parent[i]);
          }
         
        }
        
      //  }
   </script>
   

   <!-- cut parent polygon & modify line string  -->
    <script type="text/javascript">
      var tempPolygonized;
      var upperIndex = 0;
      var lowerIndex = 1;
      var leftIndex = 0;
      var rightIndex = 1;
      var horizontalSplitOperation;
      var secondPlotPercentAdj,firstPlotPercentAdj; // for adjustment
      var LineSplitterGeoJson;
      var modify = new ol.interaction.Modify({
            source: source,
          }
      ); 
      var TotalPlotArea = document.getElementById('plotTotalArea').value;
      var splittedPolygon = {
        features : []
      };
      var tempSplittedPolygon = {
        features :[]
      }
      var splittedPolygonAdjust = {
        features:[]
      }

      let draw,snap;
      var sp_1ShortLangLot = [];
      var sp_2ShortLangLot = [];
      function UtmToLangLotConverter(coordinates,array){
          for(let i = 0;i<coordinates[0].length;i++){
                const coord = proj4(utm,wgs84,[coordinates[0][i][0],coordinates[0][i][1]])
                array.push(coord);
              }
          }
      
      
      var typeSelect = "None";
      function typeSelectFunction(){
        typeSelect = "LineString";
        document.getElementById('type').disabled = true;
      }

      function addInteraction() {
        const value = typeSelect;
                if (value !== 'None') {
                    draw = new ol.interaction.Draw({
                            source: source,
                            type: typeSelect,
                });
                map.addInteraction(draw);
                draw.on("drawend", function(e){
                    var writer = new ol.format.GeoJSON();
                    LineSplitterGeoJson = writer.writeFeatures([e.feature]);
                    dynamicAreaDisplay();
                    interSectedCoordinatesLabel();
                });           
            }
      }
        var typeSelectOnChange = function () {
            document.getElementById("cutButton").disabled = false;
            map.removeInteraction(draw);
            map.removeInteraction(snap);
            addInteraction();
        };

        map.addInteraction(modify);
        modify.on('modifyend',function(e){
          sp_1ShortLangLot = [];
          sp_2ShortLangLot = [];
          var format = new ol.format["GeoJSON"]();
          LineSplitterGeoJson = format.writeFeatures(source.getFeatures());
          //lineCoordinatesLabeling()
          // for removing a layer
          RemoveSpecificLayer()
          dynamicAreaDisplay()
          //for intersected coordinates labeling 
          interSectedCoordinatesLabel()
          
          
        });
        
        function dynamicAreaDisplay(){

          splitOperationWithTurf();
          
          if(splittedPolygon.features.length == 2){
            
            let a1 = tempPolygonized.features[0].geometry.coordinates[0];
            let a2 = tempPolygonized.features[1].geometry.coordinates[0];
            horizontalSplitOperation =  identifyDirection();
            if(horizontalSplitOperation){
             
        
              AreaIdentifyHorizontalSplit(a1,a2);
        
              let area1u = "Upper Portion";
              let area2d = "Lower Portion";

                UtmToLangLotConverter(splittedPolygon.features[upperIndex].geometry.coordinates,sp_1ShortLangLot);
                const sp_area_1_polygon = turf.polygon([sp_1ShortLangLot]);
                const area_sp_1 = turf.area(sp_area_1_polygon);
                var firstPlotPercent = (area_sp_1/TotalPlotArea)*100;
                document.getElementById('sp_area_1').value = sp_area_1_polygon;
                // for lower portion  
                UtmToLangLotConverter(splittedPolygon.features[lowerIndex].geometry.coordinates,sp_2ShortLangLot);
                const sp_area_2_polygon = turf.polygon([sp_2ShortLangLot]);
                const area_sp_2 = turf.area(sp_area_2_polygon);
                document.getElementById('sp_area_2').value = sp_area_2_polygon;
                
                // //========================
                 
                  document.getElementById('sA_1').innerHTML = (firstPlotPercent).toFixed(2)  + " %" + " (" + (area_sp_1*0.00002295684113).toFixed(4) +" acre)";
                  document.getElementById('sA_2').innerHTML =  (100-firstPlotPercent).toFixed(2)+ "  %" + " (" + (area_sp_2*0.00002295684113).toFixed(4) +" acre)";
                  document.getElementById('area1').innerHTML = area1u;
                  document.getElementById('area2').innerHTML = area2d;
                  document.getElementById('a1').innerHTML = area1u;
                  document.getElementById('a2').innerHTML = area2d;
                  childPlotArea1 = (area_sp_1*0.00002295684113).toFixed(4) 
                  childPlotArea2 = (area_sp_2*0.00002295684113).toFixed(4) 
                  firstPlotPercentAdj = firstPlotPercent;
                  secondPlotPercentAdj = 100-firstPlotPercent;

                  document.getElementById('spercent1').value = parseInt(firstPlotPercent);
                  document.getElementById('spercent2').value = parseInt(100-firstPlotPercent);
            }
            else{
              AreaIdentifyVerticalSplit(a1,a2);
              let area1L = "Left Portion";
              let area2R = "Right Portion";
              UtmToLangLotConverter(splittedPolygon.features[leftIndex].geometry.coordinates,sp_1ShortLangLot);
                const sp_area_1_polygon = turf.polygon([sp_1ShortLangLot]);
                const area_sp_1 = turf.area(sp_area_1_polygon);
                var firstPlotPercent = (area_sp_1/TotalPlotArea)*100;
                document.getElementById('sp_area_1').value = sp_area_1_polygon;

                UtmToLangLotConverter(splittedPolygon.features[rightIndex].geometry.coordinates,sp_2ShortLangLot);
                const sp_area_2_polygon = turf.polygon([sp_2ShortLangLot]);
                const area_sp_2 = turf.area(sp_area_2_polygon);
                document.getElementById('sp_area_2').value = sp_area_2_polygon;
                document.getElementById('sA_1').innerHTML = (firstPlotPercent).toFixed(2)  + " %" + " (" + (area_sp_1*0.00002295684113).toFixed(4) +" acre)";
                  document.getElementById('sA_2').innerHTML =  (100-firstPlotPercent).toFixed(2)+ "  %" + " (" + (area_sp_2*0.00002295684113).toFixed(4) +" acre)";
                  document.getElementById('area1').innerHTML = area1L;
                  document.getElementById('area2').innerHTML = area2R;
                  document.getElementById('a1').innerHTML = area1L;
                  document.getElementById('a2').innerHTML = area2R;
                  childPlotArea1 = (area_sp_1*0.00002295684113).toFixed(4);
                  childPlotArea2 = (area_sp_2*0.00002295684113).toFixed(4);
                  firstPlotPercentAdj = firstPlotPercent;
                  secondPlotPercentAdj = 100-firstPlotPercent;

                  document.getElementById('spercent1').value = parseInt(firstPlotPercent);
                  document.getElementById('spercent2').value = parseInt(100-firstPlotPercent);
            }
            
                
          }
          else{
            clearPage();
          }
          
        }
     

        
        function splitOperationWithTurf(){
            var plotGeoJson = JSON.parse(plotGeo);
            var lineStringJson = JSON.parse(LineSplitterGeoJson);
            var poly = turf.polygon(plotGeoJson.coordinates[0]);
            var line = turf.polygon(lineStringJson.features[0].geometry);
            var poly_coordinates = poly.geometry.coordinates;
            var line_coordinates  = [line.geometry.coordinates.coordinates];
            var polyAsLine = turf.polygonToLine(poly);
            var makeLineGeoJson = {
              "type":"feature",
               "geometry":{
                  "coordinates":line_coordinates[0],
                  "type": "LineString"
               }
            };

            var unionedLines =  turf.union(polyAsLine,makeLineGeoJson);
            var polygonized = turf.polygonize(unionedLines);
            tempPolygonized = turf.polygonize(unionedLines);
            splittedPolygon = polygonized;

            
        }
    </script>

    <!-- script for child plot - 1 with label  -->
    <script>

      var sp_1CoordinatesLangLot = [];
         var spGeoJson_1 = {
            "type":"MultiPolygon"
        }
        function sp_1CoordinateLangLotConverter(){
              for(let i = 0;i<spGeoJson_1.coordinates[0][0].length;i++){
                //const utm = "+proj=utm +zone=32";
                //const utm = "+proj=cass +lon_0=92.0 +lat_0=24.5 +ellps=bessel +units=m"
                //const wgs84 = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs";
                const coord = proj4(utm,wgs84,[spGeoJson_1.coordinates[0][0][i][0],spGeoJson_1.coordinates[0][0][i][1]])
                sp_1CoordinatesLangLot.push(coord);
              }
          }
      function DisplaySplitPoly1(){
        
        let index = 1;
        if(!horizontalSplitOperation){
          if(leftIndex == 0) index = 0;
        }
        else{
          if(upperIndex == 0) index = 0;
        }
        
     
                var source_sp_1 = new ol.source.Vector({wrapX: false});
                vector_sp_1 = new ol.layer.Vector({
                    source: source_sp_1,
                });
              
                var map_sp_1 = new ol.Map({
                    target: 'map_sp_1',
                    layers: [
                        vector_sp_1,

                        new ol.layer.Graticule({
                          // the style to use for the lines, optional.
                          strokeStyle: new ol.style.Stroke({
                            color: 'rgba(255,120,0,0.9)',
                            width: 1,
                            lineDash: [10,10],
                          }),
                          showLabels: true ,
                          wrapX: false ,
                        }),
                    ],
                    view: new ol.View()
                });
           
            var geometry_sp_1 = new ol.format.GeoJSON().readGeometry(splittedPolygon.features[index].geometry);
            spGeoJson_1.coordinates = [splittedPolygon.features[index].geometry.coordinates];
            // for saving perpous
            document.getElementById('spGeoJson_1').value = JSON.stringify(spGeoJson_1);
            
            map_sp_1.addLayer(
                new ol.layer.Vector({
                  source: new ol.source.Vector({
                    features: [new ol.Feature(geometry_sp_1)]
                  }),
                  style: new ol.style.Style({
                      stroke: new ol.style.Stroke({
                        color: 'black',
                        width: 1,
                        opacity:0.5
                      })
                  })
         
                })
              );
              map_sp_1.addLayer(
                  new ol.layer.Graticule({
                  // the style to use for the lines, optional.
                  strokeStyle: new ol.style.Stroke({
                    color: 'rgba(255,120,0,0.9)',
                    width: 1,
                    lineDash: [10,10],
                  }),
                  showLabels: true ,
                  wrapX: true ,
                }),
        
              )
              map_sp_1.getView().fit(geometry_sp_1);
              sp_1ShortLangLot = []
              UtmToLangLotConverter(splittedPolygon.features[index].geometry.coordinates,sp_1ShortLangLot);
              const sp_area_1_polygon = turf.polygon([sp_1ShortLangLot]);
              const area_sp_1 = turf.area(sp_area_1_polygon);
              document.getElementById('area_sp_1').innerHTML = "Area : " + (area_sp_1*0.00002295684113).toFixed(4)+ " acre ";
              
          //adding label for splitted polygon -1 
               // getting distance
          var midPointArray_sp_plot_1 = [];
          var coordinateDistance_sp_plot_1 = [];
     
        
          sp_1CoordinateLangLotConverter();

          function designDistance_sp_plot_1(spGeoJson_1,coordinateDistance){
            const length = spGeoJson_1.coordinates[0][0].length;
              for(let i = 1;i<length;i++){
                  var coord = spGeoJson_1.coordinates[0][0];
                  var dist = distance(sp_1CoordinatesLangLot[i-1][0],sp_1CoordinatesLangLot[i][0],sp_1CoordinatesLangLot[i-1][1],sp_1CoordinatesLangLot[i][1]);
                  coordinateDistance.push(dist);
              }
              coordinateDistance.push(distance(sp_1CoordinatesLangLot[length-1][0],sp_1CoordinatesLangLot[0][0],sp_1CoordinatesLangLot[length-1][1],sp_1CoordinatesLangLot[0][1]));
            }

            designDistance_sp_plot_1(spGeoJson_1,coordinateDistance_sp_plot_1);
          // distance of coordinates
        
          // mid point of coordinates
          function midPointOfCoordinates_sp_plot_1(spGeoJson_1,midPointArray_sp_plot_1){
            let coord = spGeoJson_1.coordinates[0][0];
            for(let i = 1;i<coord.length;i++){
              let midx = (coord[i-1][0] + coord[i][0])/2;
              let midy = (coord[i-1][1] + coord[i][1])/2;
              midPointArray_sp_plot_1.push([midx,midy]);
            }
            midPointArray_sp_plot_1.push([(coord[0][0] + coord[coord.length - 1][0])/2,(coord[0][1] + coord[coord.length-1][1])/2]);

          }

          midPointOfCoordinates_sp_plot_1(spGeoJson_1,midPointArray_sp_plot_1);

          // function to add label :
          function displayLabelFor_sp_plot_1(coordx,coordy,distance){       
                //const utm = "+proj=utm +zone=32";
                //const utm = "+proj=cass +lon_0=92.0 +lat_0=24.5 +ellps=bessel +units=m"
                //const wgs84 = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs";
                const coord = proj4(utm,wgs84,[coordx, coordy])
                const labelFeature_sp_plot_1 = new ol.Feature({
                    geometry: new ol.geom.Point([coordx,coordy]),
                });

                const labelonly_sp_plot_1 = new ol.style.Style({
                    text: new ol.style.Text({
                        font: '10px sans-serif',
                        text:`${distance.toFixed(1)} ft`,
                        fill: new ol.style.Fill({
                            color: 'red'
                        }),
                    })
                });

                labelFeature_sp_plot_1.setStyle(labelonly_sp_plot_1);
                const vectorSource_for_sp_plot_1 = new ol.source.Vector({
                    features: [labelFeature_sp_plot_1]
                });

            
                map_sp_1.addLayer(
                    new ol.layer.Vector({
                        source: vectorSource_for_sp_plot_1
                    })
                );
            }
               //start 
      function StyleCoordinatesOnSp_plot_1(coordx,coordy){
        const labelFeature_sp_1 = new ol.Feature({
                geometry: new ol.geom.Point([coordx,coordy]),
            });
            const labelonly_sp_1 = new ol.style.Style({
                image: new ol.style.Circle({
                    radius: 4,
                    fill: new ol.style.Fill({color: 'blue'})
                })
            });

            labelFeature_sp_1.setStyle(labelonly_sp_1);
            const vectorSource_for_sp_1_label = new ol.source.Vector({
                features: [labelFeature_sp_1]
            });
            map_sp_1.addLayer(
                new ol.layer.Vector({
                    source: vectorSource_for_sp_1_label
                })
            );
      }
      
       var spVartex_1 =splittedPolygon.features[index].geometry.coordinates[0];
       
       for(let i = 0;i<spVartex_1.length;i++){
          StyleCoordinatesOnSp_plot_1(spVartex_1[i][0],spVartex_1[i][1]);
       }

          for(let i = 0;i<midPointArray_sp_plot_1.length;i++){
            if(coordinateDistance_sp_plot_1[i]>0)
              displayLabelFor_sp_plot_1(midPointArray_sp_plot_1[i][0],midPointArray_sp_plot_1[i][1], coordinateDistance_sp_plot_1[i]);
            }
          }
    </script>



    <!-- splitted polygon -2  -->
    
    <script>
        var sp_2CoordinatesLangLot = [];
       var spGeoJson_2 = {
            "type":"MultiPolygon"
        }
       function DisplaySplitPoly2(){
        let index = 0; 
        if(!horizontalSplitOperation){
          if(rightIndex == 1) index = 1;
        }
        else{
          if(lowerIndex == 1)index = 1;
        }
        
        
          var source_sp_2 = new ol.source.Vector({wrapX: false});
          var vector_sp_2 = new ol.layer.Vector({
              source: source_sp_2,
          });

          var map_sp_2 = new ol.Map({
              target: 'map_sp_2',
              layers: [
                  vector_sp_2,
                  new ol.layer.Graticule({
                // the style to use for the lines, optional.
                strokeStyle: new ol.style.Stroke({
                  color: 'rgba(255,120,0,0.9)',
                  width: 1,
                  lineDash: [10,10],
                }),
                showLabels: true ,
                wrapX: false ,
                
              }),
              ],
              view: new ol.View()
          });
    

  
        var geometry_sp_2 = new ol.format.GeoJSON().readGeometry(splittedPolygon.features[index].geometry);
        console.log(splittedPolygon.features[index].geometry);
        map_sp_2.addLayer(
            new ol.layer.Vector({
              source: new ol.source.Vector({
                features: [new ol.Feature(geometry_sp_2)]
              }),
              style: new ol.style.Style({
                      stroke: new ol.style.Stroke({
                        color: 'black',
                        width: 1,
                        opacity:0.5
                      })
                  })
            })
          );
          map_sp_2.getView().fit(geometry_sp_2);
          map_sp_2.addLayer(
            new ol.layer.Graticule({
                // the style to use for the lines, optional.
                strokeStyle: new ol.style.Stroke({
                  color: 'rgba(255,120,0,0.9)',
                  width: 1,
                  lineDash: [10,10],
                }),
                showLabels: true ,
                wrapX: true ,
              }),
        
          )
          sp_2ShortLangLot = []
          UtmToLangLotConverter(splittedPolygon.features[index].geometry.coordinates,sp_2ShortLangLot);
          const sp_area_2_polygon = turf.polygon([sp_2ShortLangLot]);
          const area_sp_2 = turf.area(sp_area_2_polygon);
          document.getElementById('area_sp_2').innerHTML = "Area : " + (area_sp_2*0.00002295684113).toFixed(4) + " acre ";
          spGeoJson_2.coordinates = [splittedPolygon.features[index].geometry.coordinates];
          // label for splitted polygon -2 
          var midPointArray_sp_plot_2 = [];
          var coordinateDistance_sp_plot_2 = [];
        
          function sp_2CoordinateLangLotConverter(){
              for(let i = 0;i<spGeoJson_2.coordinates[0][0].length;i++){
                //const utm = "+proj=utm +zone=32";
                //const utm = "+proj=cass +lon_0=92.0 +lat_0=24.5 +ellps=bessel +units=m"
                //const wgs84 = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs";
                const coord = proj4(utm,wgs84,[spGeoJson_2.coordinates[0][0][i][0],spGeoJson_2.coordinates[0][0][i][1]])
                sp_2CoordinatesLangLot.push(coord);
              }
          }
          sp_2CoordinateLangLotConverter();
          function designDistance_sp_plot_2(spGeoJson_2,coordinateDistance){
            const length = spGeoJson_2.coordinates[0][0].length;
              for(let i = 1;i<length;i++){
                  var coord = spGeoJson_2.coordinates[0][0];
                  var dist = distance(sp_2CoordinatesLangLot[i-1][0],sp_2CoordinatesLangLot[i][0],sp_2CoordinatesLangLot[i-1][1],sp_2CoordinatesLangLot[i][1]);
                  coordinateDistance.push(dist);
              }
              coordinateDistance.push(distance(sp_2CoordinatesLangLot[length-1][0],sp_2CoordinatesLangLot[0][0],sp_2CoordinatesLangLot[length-1][1],sp_2CoordinatesLangLot[0][1]));

            }
            
         
            designDistance_sp_plot_2(spGeoJson_2,coordinateDistance_sp_plot_2);
     
       
          // mid point of coordinates
          


          function midPointOfCoordinates_sp_plot_2(spGeoJson_2,midPointArray_sp_plot_2){
            let coord = spGeoJson_2.coordinates[0][0];
            
            for(let i = 1;i<coord.length;i++){
              let midx = (coord[i-1][0] + coord[i][0])/2;
              let midy = (coord[i-1][1] + coord[i][1])/2;
              midPointArray_sp_plot_2.push([midx,midy]);
            }
            midPointArray_sp_plot_2.push([(coord[0][0] + coord[coord.length - 1][0])/2,(coord[0][1] + coord[coord.length-1][1])/2]);
          }
          midPointOfCoordinates_sp_plot_2(spGeoJson_2,midPointArray_sp_plot_2);

          // function to add label :
          function displayLabelFor_sp_plot_2(coordx,coordy,distance){
            //const utm = "+proj=cass +lon_0=92.0 +lat_0=24.5 +ellps=bessel +units=m"
                //const utm = "+proj=utm +zone=32";
                
                //const wgs84 = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs";
                const coord = proj4(utm,wgs84,[coordx, coordy])
                const labelFeature_sp_plot_2= new ol.Feature({
                    geometry: new ol.geom.Point([coordx,coordy]),
                });

                const labelonly_sp_plot_2 = new ol.style.Style({
                    text: new ol.style.Text({
                        font: '10px sans-serif',
                        text:`${distance.toFixed(1)} ft`,
                        fill: new ol.style.Fill({
                            color: 'red'
                        }),
                    })
                });

                labelFeature_sp_plot_2.setStyle(labelonly_sp_plot_2);
                const vectorSource_for_sp_plot_2 = new ol.source.Vector({
                    features: [labelFeature_sp_plot_2]
                });

            
                map_sp_2.addLayer(
                    new ol.layer.Vector({
                        source: vectorSource_for_sp_plot_2
                    })
                );
            }
                           //start 
      function StyleCoordinatesOnSp_plot_2(coordx,coordy){
        const labelFeature_sp_2 = new ol.Feature({
                geometry: new ol.geom.Point([coordx,coordy]),
            });
            const labelonly_sp_2 = new ol.style.Style({
                image: new ol.style.Circle({
                    radius: 4,
                    fill: new ol.style.Fill({color: 'blue'})
                })
            });

            labelFeature_sp_2.setStyle(labelonly_sp_2);
            const vectorSource_for_sp_2_label = new ol.source.Vector({
                features: [labelFeature_sp_2]
            });
            map_sp_2.addLayer(
                new ol.layer.Vector({
                    source: vectorSource_for_sp_2_label
                })
            );
      }
      
       var spVartex_2 =splittedPolygon.features[index].geometry.coordinates[0];
       
       for(let i = 0;i<spVartex_2.length;i++){
          StyleCoordinatesOnSp_plot_2(spVartex_2[i][0],spVartex_2[i][1]);
       }
          for(let i = 0;i<midPointArray_sp_plot_2.length;i++){
            if(coordinateDistance_sp_plot_2[i]>0)
              displayLabelFor_sp_plot_2(midPointArray_sp_plot_2[i][0],midPointArray_sp_plot_2[i][1], coordinateDistance_sp_plot_2[i]);
            }
               //  for saving perpous
               document.getElementById('spGeoJson_2').value =JSON.stringify(spGeoJson_2)
          
        }
    </script>
    <script>
      function clearPage(){
        window.location.reload();
      } 
    </script>
    <script>

      function displayCutMessage(){
        alert("Split Operation Done");
      }
      document.getElementById("cutButton").disabled = true;
      document.getElementById("saveButton").disabled = true;
      function buttonEnableDisable(){
        document.getElementById("cutButton").disabled = true;
        document.getElementById("saveButton").disabled = false;
      }
    </script>

    <!-- automated Line String  -->
  

    <!-- labeling for dynamic line String coordinates intersection   -->
    <script>
      var selectedCoordinates = [];
      var lineCoordinates;
      function interSectedCoordinatesLabel(){
        selectedCoordinates = [];
        const coordinatesNList = [];
        const plot = JSON.parse(plotGeo);
        lineCoordinates = JSON.parse(LineSplitterGeoJson).features[0].geometry.coordinates;
        let lineString = turf.lineString(lineCoordinates);
        let intersectsArray = [];
        let plotCoordinates = plot.coordinates[0][0];
        for(let i = 1;i<plotCoordinates.length;i++){
          let x1 = plotCoordinates[i-1][0];
          let x2 = plotCoordinates[i][0];
          let y1 = plotCoordinates[i-1][1];
          let y2 = plotCoordinates[i][1];
          let polyLineString = turf.lineString([[x1,y1],[x2,y2]]);
          let tx = turf.lineIntersect(lineString, polyLineString);
          if(tx.features.length !=0){
            // [x1,y1] first coordinate // [x2,y2] second coordinate  // [x3,y3] middle coordinates 
            let xo = tx.features[0].geometry.coordinates[0];
            let yo = tx.features[0].geometry.coordinates[1];
            selectedCoordinates.push([[x1,y1],[x2,y2],[xo,yo]]);
            
          }
          intersectsArray.push(tx);
        }
        let intersectedLineCoordinates = [];
        for(let i = 0;i<intersectsArray.length;i++){
          if(intersectsArray[i].features[0]){
            const coordi = intersectsArray[i].features[0].geometry.coordinates;
            intersectedLineCoordinates.push(coordi);
            function randomNumber(min, max) {
              return Math.random() * (max - min) + min;
            }
            let col =  randomNumber(0, 255);
            StyleCoordinatesInterceted(coordi[0],coordi[1]);
          }
        }
        console.log(intersectedLineCoordinates);
        let newLineDistance =  lineStringDistance(intersectedLineCoordinates);
        let mid   = midPoint(intersectedLineCoordinates[0][0],intersectedLineCoordinates[1][0],intersectedLineCoordinates[0][1],intersectedLineCoordinates[1][1]);
       // addLineDistanceLabel(mid[0],mid[1],newLineDistance);
        //lineStringPercentageBreakDownHorizontal();
        selectDirection();
      }

      function ToLatLong(coordx,coordy){
        let utm_x = "+proj=utm +zone=32";
        let wgs84_x = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs";
        return proj4(utm_x,wgs84_x,[coordx, coordy]);
      }

      function lineStringDistance(intersectedLineCoordinates){
        let lat1 = ToLatLong(intersectedLineCoordinates[0][0],intersectedLineCoordinates[0][1]);
        let lat2 = ToLatLong(intersectedLineCoordinates[1][0],intersectedLineCoordinates[1][1]);
        return distance(lat1[0],lat2[0],lat1[1],lat2[1]);
      }
      function midPoint(x1,x2,y1,y2){
        let x = (x1+x2)/2;
        let y = (y1+y2)/2;
        return [x,y];
      }
 

      function addLineDistanceLabel(coordx,coordy,distance){
        const labelFeature = new ol.Feature({
                geometry: new ol.geom.Point([coordx,coordy]),
         });
            const labelonly = new ol.style.Style({
              text: new ol.style.Text({
                    font: '10px sans-serif',
                    text:`${(distance).toFixed(1)} ft`,
                    fill: new ol.style.Fill({
                        color: 'black'
                    }),
                    
                })
            });

            labelFeature.setStyle(labelonly);
            const vectorSource = new ol.source.Vector({
                features: [labelFeature]
            });
            map.addLayer(
                new ol.layer.Vector({
                    source: vectorSource
                })
            );
      }


      function StyleCoordinatesInterceted(coordx,coordy){
          const labelFeature = new ol.Feature({
                geometry: new ol.geom.Point([coordx,coordy]),
          });
            const labelonly = new ol.style.Style({
                image: new ol.style.Circle({
                        radius: 5,
                        stroke: new ol.style.Stroke({
                        color: `rgba(255,0,0,1)`,
                  }),
                }),
              });

            labelFeature.setStyle(labelonly);
            const vectorSource = new ol.source.Vector({
                features: [labelFeature]
            });
            map.addLayer(
                new ol.layer.Vector({
                    source: vectorSource
                })
            );
      }
    </script>
     <!-- function for line string percentage Horizontal  -->
     <script>
      function selectDirection(){
        let y2 = lineCoordinates[1][1];
        let y1 = lineCoordinates[0][1];
        let x2 = lineCoordinates[1][0];
        let x1 = lineCoordinates[0][0];
        let m = (y2-y1)/(x2-x1);
        let angle = Math.atan(m)*57.2958;
        console.log("Degree : "+ angle);
        //console.log(lineCoordinates);
        let angularDistanceX = angle - 0;
        let angularDistanceY = 90-angle;
        let closeToAxis = "";
        if(angle<70 && angle>-70){
          closeToAxis = "Close to X axis";
          //lineStringPercentageBreakDownHorizontal();
        }
        else{
          closeToAxis = "Close to Y axis";
          //lineStringPercentageBreakDownVertical();
        }
      }
      var percentDistance1V,percentDistance2V;
      function lineStringPercentageBreakDownVertical(){
        let cX1,cY1;
        let cX2,cY2;
        if(selectedCoordinates[0][0][0] < selectedCoordinates[0][1][0]){
          cX1 = selectedCoordinates[0][0][0];
          cY1 = selectedCoordinates[0][0][1]; 
        }
        else{
          cX1 = selectedCoordinates[0][1][0];
          cY1 = selectedCoordinates[0][1][1];
        }

        if(selectedCoordinates[1][0][0] < selectedCoordinates[1][1][0]){
          cX2 = selectedCoordinates[1][0][0];
          cY2 = selectedCoordinates[1][0][1]; 
        }
        else{
          cX2 = selectedCoordinates[1][1][0];
          cY2 = selectedCoordinates[1][1][1]; 
        }
        
        let cF = ToLatLong(cX1,cY1);
        let cS = ToLatLong(cX2,cY2);
        
        let inter1 = ToLatLong(selectedCoordinates[0][2][0],selectedCoordinates[0][2][1]);
        let interX1 = inter1[0];
        let interY1 = inter1[1];
        let inter2 = ToLatLong(selectedCoordinates[1][2][0],selectedCoordinates[1][2][1]);
        let interX2 = inter2[0];
        let interY2 = inter2[1];
        let distCoord_1Intersected = distance(cF[0],interX1,cF[1],interY1);
        let distCoord_2Intercected = distance(cS[0],interX2,cS[1],interY2);
        let latlong11 = ToLatLong(selectedCoordinates[0][0][0],selectedCoordinates[0][0][1]);
        let latlong12 = ToLatLong(selectedCoordinates[0][1][0],selectedCoordinates[0][1][1]);
        let latlong21 = ToLatLong(selectedCoordinates[1][0][0],selectedCoordinates[1][0][1]);
        let latlong22 = ToLatLong(selectedCoordinates[1][1][0],selectedCoordinates[1][1][1]);
        let distCoord_1 = distance(latlong11[0],latlong12[0],latlong11[1],latlong12[1]);
        let distCoord_2 = distance(latlong21[0],latlong22[0],latlong21[1],latlong22[1]);
        percentDistance1V = parseInt(100*distCoord_1Intersected/distCoord_1);
        percentDistance2V = parseInt(100*distCoord_2Intercected/distCoord_2);
        let l1,l2;
       

        //StyleCoordinatesPecentage(cX1,cY1,0,255,255);
        //displayLabelForLineStringPercentageBreakDown(cX1-5,cY1-5,percentDistance1V)
        //displayLabelForLineStringPercentageBreakDown(cX2-5,cY2+4,percentDistance2V)
        //StyleCoordinatesPecentage(cX2,cY2,255,255,0);
        
      }
      var percentDistance1H,percentDistance2H;
      var coordinatesSelectedDatas = {
        
      }
      function lineStringPercentageBreakDownHorizontal(){
        let cX1,cY1;
        let cX2,cY2;
        if(selectedCoordinates[0][0][1]>selectedCoordinates[0][1][1]){
          cX1 = selectedCoordinates[0][0][0];
          cY1 = selectedCoordinates[0][0][1];
        }
        else {
          cX1 = selectedCoordinates[0][1][0];
          cY1 = selectedCoordinates[0][1][1];
        }
        if(selectedCoordinates[1][0][1] > selectedCoordinates[1][1][1]){
          cX2 = selectedCoordinates[1][0][0];
          cY2 = selectedCoordinates[1][0][1];
        }
        else {
          cX2 = selectedCoordinates[1][1][0];
          cY2 = selectedCoordinates[1][1][1];
        }
        let cF = ToLatLong(cX1,cY1);
        let cS = ToLatLong(cX2,cY2);
  
        let inter1 = ToLatLong(selectedCoordinates[0][2][0],selectedCoordinates[0][2][1]);
        let interX1 = inter1[0];
        let interY1 = inter1[1];
        let inter2 = ToLatLong(selectedCoordinates[1][2][0],selectedCoordinates[1][2][1]);
        let interX2 = inter2[0];
        let interY2 = inter2[1];
        let distCoord_1Intersected = distance(cF[0],interX1,cF[1],interY1);
        let distCoord_2Intercected = distance(cS[0],interX2,cS[1],interY2);
        let latlong11 = ToLatLong(selectedCoordinates[0][0][0],selectedCoordinates[0][0][1]);
        let latlong12 = ToLatLong(selectedCoordinates[0][1][0],selectedCoordinates[0][1][1]);
        let latlong21 = ToLatLong(selectedCoordinates[1][0][0],selectedCoordinates[1][0][1]);
        let latlong22 = ToLatLong(selectedCoordinates[1][1][0],selectedCoordinates[1][1][1]);
        let distCoord_1 = distance(latlong11[0],latlong12[0],latlong11[1],latlong12[1]);
        let distCoord_2 = distance(latlong21[0],latlong22[0],latlong21[1],latlong22[1]);
        percentDistance1H = parseInt(100*distCoord_1Intersected/distCoord_1);
        percentDistance2H = parseInt(100*distCoord_2Intercected/distCoord_2);
        let l1,l2;
        if(cX1>cX2){
          if(lineCoordinates[0][0]>lineCoordinates[1][0]){
              l1 = [lineCoordinates[1][0]+2,lineCoordinates[1][1]+2];
              l2 = [lineCoordinates[0][0]+2,lineCoordinates[0][1]+2];
            }
            else{
              l1 = [lineCoordinates[0][0]+2,lineCoordinates[0][1]+2];
              l2 = [lineCoordinates[1][0]+2,lineCoordinates[1][1]+2];
            }
         // displayLabelForLineStringPercentageBreakDown(l1[0],l1[1],percentDistance2H);
         // displayLabelForLineStringPercentageBreakDown(l2[0],l2[1],percentDistance1H);
        }
        else{
          if(lineCoordinates[0][0]>lineCoordinates[1][0]){
            l1 = [lineCoordinates[1][0]+2,lineCoordinates[1][1]+2]
            l2 = [lineCoordinates[0][0]+2,lineCoordinates[0][1]+2]
            }
            else{
              l1 = [lineCoordinates[0][0]+2,lineCoordinates[0][1]+2]
              l2 = [lineCoordinates[1][0]+2,lineCoordinates[1][1]+2]
            }
           // displayLabelForLineStringPercentageBreakDown(l1[0],l1[1],percentDistance1H);
           // displayLabelForLineStringPercentageBreakDown(l2[0],l2[1],percentDistance2H);
        }

       // StyleCoordinatesPecentage(cX1,cY1);
       // StyleCoordinatesPecentage(cX2,cY2);

        
 
          
          

      }

      

      function StyleCoordinatesPecentage(coordx,coordy){
          const labelFeature = new ol.Feature({
                geometry: new ol.geom.Point([coordx,coordy]),
          });
            const labelonly = new ol.style.Style({
              image: new ol.style.Circle({
                        radius: 5,
                        stroke: new ol.style.Stroke({
                        color: `rgba(255,0,0,5)`,
                  }),
                }),
            });

            labelFeature.setStyle(labelonly);
            const vectorSource = new ol.source.Vector({
                features: [labelFeature]
            });
            map.addLayer(
                new ol.layer.Vector({
                    source: vectorSource
                })
            );
      };
      

      function displayLabelForLineStringPercentageBreakDown(coordx,coordy,percent){
        const labelFeature_bd = new ol.Feature({
                geometry: new ol.geom.Point([coordx,coordy]),
          });
            const labelonly_bd = new ol.style.Style({
              text: new ol.style.Text({
                        font: '12px sans-serif',
                        text:`${percent} %`,
                        fill: new ol.style.Fill({
                            color: 'black'
                        }),
              })
            });

            labelFeature_bd.setStyle(labelonly_bd);
            const vectorSource_bd  = new ol.source.Vector({
                features: [labelFeature_bd]
            });
            map.addLayer(
                new ol.layer.Vector({
                    source: vectorSource_bd
                })
            );
      }
    </script>
 
    <!-- polygon split into n equal section  -->
    <script>
      function polygonNDivision(nDivisions,colors){
        var  polygon = turf.polygon([parentCoordinatesLangLot]);
        var polygonBbox = turf.bbox(polygon);
        var randomPoints = turf.randomPoint(100000, {bbox: polygonBbox});
        randomPoints.features = randomPoints.features.filter((feature) => {
          return(turf.booleanPointInPolygon(feature.geometry.coordinates, polygon));
        });
        var clusteredPoints = turf.clustersKmeans(randomPoints, {
          numberOfClusters: nDivisions,
        });
        var centroidPoints = [];
        for (var i = 0; i < nDivisions; i++) {
          var feature = clusteredPoints.features.find(
            function(feature) {
              return(feature.properties.cluster == i);
            }
          );
          centroidPoints[i] = turf.point(feature.properties.centroid);
        }
        var voronoiPolygons = turf.voronoi(
          {type: "FeatureCollection", features: centroidPoints, },
          {bbox: polygonBbox}
        );
        var polygonArea = turf.area(polygon);
        var idealPieceArea = polygonArea / nDivisions;
        var clippedVoronoiPolygons = voronoiPolygons.features.map((feature, i) => {
            var clippedFeature = turf.intersect(feature.geometry, polygon);
            clippedFeatureArea = turf.area(clippedFeature);
            clippedFeature.properties.percentage = clippedFeatureArea / idealPieceArea;
            clippedFeature.properties.color = colors[i];
            return(clippedFeature);
          });
          clippedVoronoiPolygons = turf.featureCollection(clippedVoronoiPolygons);
          var dividedPolygonFeatures = new ol.format.GeoJSON().readFeatures(clippedVoronoiPolygons,{dataProjection: 'EPSG:4326', featureProjection: 'EPSG:3857'});
          var nGeoJSON = [];
          for(let i = 0;i<dividedPolygonFeatures.length;i++){
            nGeoJSON.push(toGeoJSONFormatNPolygons(dividedPolygonFeatures[i].getGeometry().getCoordinates()));
          }
          return(dividedPolygonFeatures);
      }
      function toGeoJSONFormatNPolygons(coordinates){
        var tempPolyGeoJson = {
          "type":"Polygon",
          "coordinates":coordinates
        }
        return tempPolyGeoJson;
      }
      function get_random_rgb(opacity) {
        var rgb = [Math.floor(Math.random() * 256),Math.floor(Math.random() * 256),Math.floor(Math.random() * 256)];
        return('rgb('+rgb.join(', ') + ', ' + opacity + ')');
      }
           
      function nDivisionLayer(){
        var nDivisions = document.getElementById('nDivision').value || 1;
        var colors = [];
        for (var i = 0; i < nDivisions; i++) {
          colors.push(get_random_rgb(0.5));
        }
         function style(feature) {
          var style = new ol.style.Style({
          stroke: new ol.style.Stroke({
              color: [0, 0, 255, 0.8],
              width: 1
          }),
          fill: new ol.style.Fill({
              color: feature.get('color'),
          }),
          text: new ol.style.Text({
            text: Math.floor(feature.get('percentage') * 100) + '%'
          })
        });
          return(style);
      }
      
        var polygons =  polygonNDivision(nDivisions,colors);
        let latLong = polygons[0].getGeometry().getCoordinates()[0][0];
        var raster = new ol.layer.Tile({
          source: new ol.source.OSM()
        });
        var vectorLayer = new ol.layer.Vector({
          source: new ol.source.Vector(),
          style: style
        });

        var map_es = new ol.Map({
          layers: [vectorLayer],
          target: 'map_sp_3',
          view: new ol.View({
            center: latLong,
            zoom: 20
          })
        });
        vectorLayer.getSource().addFeatures(polygons);
      }
    </script>
     
    <script>
      function map_sp_3Div(){
        document.getElementById('map_sp_3').hidden = false;
      }
    </script>

    <!-- Removing specific layer function  -->
    <script>
      function RemoveSpecificLayer(){
          let layersList =  map.getLayers().getArray();
          let initial= layersList.length;
          let count = 1;
          for(let i = layersList.length-1;count<3;i--){
            map.getLayers().getArray()[i].setVisible(false);
            count++;
          }        
      }
      
    </script>
    
    <!-- Display parent & child plot in combine form  -->
    <script>
      var combineGeoJson = JSON.parse(document.getElementById('combineGeoJson').value);
      if(combineGeoJson.type == "EmptyGeoJSON" ){
        document.getElementById('parentChildCombineGeoJson').style.visibility='hidden'
      }
      else{
        function combinParentChildPlotDisplay(){     
          document.getElementById('parentChildCombine').innerHTML = "";   
            var combineGeoJson = JSON.parse(document.getElementById('combineGeoJson').value);
              setTimeout(()=>{
              var mapCombine = new ol.Map({
                  target: 'parentChildCombine',
                  layers: [
                      new ol.layer.Graticule({
                      // the style to use for the lines, optional.
                      visible: true,
                      strokeStyle: new ol.style.Stroke({
                        color: 'rgba(255,120,0,0.9)',
                        width: 1,
                        lineDash: [10,10],
                      }),
                      showLabels: true ,
                      wrapX: false ,
                    }),
                      
                      
                  ],
                  view: new ol.View()
              });
            
            var combineGeometry = new ol.format.GeoJSON().readGeometry(combineGeoJson);
          
            mapCombine.addLayer(
              new ol.layer.Vector({
                source: new ol.source.Vector({
                  features: [new ol.Feature(combineGeometry)]
                }),
                style: new ol.style.Style({
                    stroke: new ol.style.Stroke({
                      color: 'black',
                      width: 1,
                      opacity: 0.25
                    })
                  })
              
              })
            );
          

              mapCombine.getView().fit(combineGeometry);
          },1000)

      }
    }
       
    </script>
    
    <script>
      
      function Adjustment(){
        let parentPlotArea = document.getElementById("plotTotalArea").value;
        parentPlotArea = (parseFloat(parentPlotArea)*0.00002295684113).toFixed(2);
        console.log(childPlotArea1);
        console.log(childPlotArea2);
        let p1 = (childPlotArea1/parentPlotArea)*100;
        let p2 =(childPlotArea2/parentPlotArea)*100;
        console.log(p1, " " , p2);
        let nP1 = 50-p1;
        let nP2 = 50-p2;
        let c = JSON.parse(LineSplitterGeoJson).features[0].geometry.coordinates;
        let Point1 = [c[0][0],c[0][1]];
        let Point2 = [c[1][0],c[1][1]];

        
        //let iPoint1 = [selectedCoordinates[0][2][0],selectedCoordinates[0][2][1]];
        let iPoint1 = [selectedCoordinates[1][2][0],selectedCoordinates[1][2][1]];
         
        let i = 1;
        let bigArea,smallArea;
        console.log(firstPlotPercentAdj , " " , secondPlotPercentAdj)
        if(firstPlotPercentAdj>secondPlotPercentAdj){
          bigArea   = firstPlotPercentAdj;
          smallArea = secondPlotPercentAdj;
        }
        else{
          bigArea   = secondPlotPercentAdj;
          smallArea = firstPlotPercentAdj;
        }
        let areaNeeded = bigArea - smallArea;
        while(true){
          Point2 = [c[1][0]+i,c[1][1]+i];
          autoDisplayArea(Point1,Point2);
          // NewLineSplitterDisplay(Point1,Point2);
          if(parseInt(secondPlotPercentAdj-firstPlotPercentAdj) == 0){
            //NewLineSplitterDisplay(Point1,Point2);
            break;
          }
          i++;
        }
     
      }
    </script>


  
    <!-- lang lot to utm -->

<script>
 
  function SplitOperationWithDynamicLineString(vertices){
            var plotGeoJson = JSON.parse(plotGeo);
            var poly = turf.polygon(plotGeoJson.coordinates[0]);
            var poly_coordinates = poly.geometry.coordinates;
            var polyAsLine = turf.polygonToLine(poly);
            var makeLineGeoJson = {
              "type":"feature",
               "geometry":{
                  "coordinates":vertices,
                  "type": "LineString"
               }
            };
            var unionedLines =  turf.union(polyAsLine,makeLineGeoJson);
            const polygonized = turf.polygonize(unionedLines);
            splittedPolygonAdjust = polygonized;
            console.log(makeLineGeoJson)
            //console.log(splittedPolygonAdjust);
        }
        function autoDisplayArea(vertices){
          let nodes = vertices;
          var sp_1ShortLangLotAdj = [];
          var sp_2ShortLangLotAdj = [];
          SplitOperationWithDynamicLineString(nodes);
          // DisplaySplitPoly1();DisplaySplitPoly2();buttonEnableDisable();
           if(splittedPolygonAdjust.features.length == 2){
             UtmToLangLotConverter(splittedPolygonAdjust.features[0].geometry.coordinates,sp_1ShortLangLotAdj);
               const sp_area_1_polygonAdj = turf.polygon([sp_1ShortLangLotAdj]);
               const area_sp_1 = turf.area(sp_area_1_polygonAdj);
               firstPlotPercentAdj = parseInt((area_sp_1/TotalPlotArea)*100);
               document.getElementById('sA_1').innerHTML = firstPlotPercentAdj.toFixed(2)  + " %" + " (" + (area_sp_1*0.00002295684113).toFixed(4) +" acre)";
               document.getElementById('sp_area_1').value = sp_area_1_polygonAdj;
               UtmToLangLotConverter(splittedPolygonAdjust.features[1].geometry.coordinates,sp_2ShortLangLotAdj);
               const sp_area_2_polygonAdj = turf.polygon([sp_2ShortLangLotAdj]);
               const area_sp_2 = turf.area(sp_area_2_polygonAdj);
               secondPlotPercentAdj = parseInt((100-firstPlotPercentAdj));
               document.getElementById('sA_2').innerHTML =  (100-firstPlotPercentAdj).toFixed(2)+ "  %" + " (" + (area_sp_2*0.00002295684113).toFixed(4) +" acre)";
               document.getElementById('sp_area_2').value = sp_area_2_polygonAdj;
               childPlotArea1 = (area_sp_1*0.00002295684113).toFixed(4) 
               childPlotArea2 = (area_sp_2*0.00002295684113).toFixed(4) 
           }
           else{
            //  clearPage();
            console.log("This coordinate cannot be taken")
           }
        }
</script>

<script>
  var vertices  ;
  function lineCoordinatesLabeling(){
    let lineString = JSON.parse(LineSplitterGeoJson);
    vertices = lineString.features[0].geometry.coordinates;
    let array = [
      [selectedCoordinates[0][2][0],selectedCoordinates[0][2][1]],
      [selectedCoordinates[1][2][0],selectedCoordinates[1][2][1]]
    ];

    if(selectedCoordinates[0][1][0]<selectedCoordinates[1][0][0]){
      array.sort(function(a, b) {
        return a[0] - b[0];
      });
      vertices[0] = [array[0][0],array[0][1]];
      vertices[vertices.length-1] = [array[1][0],array[1][1]];
    }
    if(selectedCoordinates[0][1][1]< selectedCoordinates[1][1][1]){
      vertices[0] = [array[1][0],array[1][1]];
      vertices[vertices.length-1] =[array[0][0],array[0][1]];
    }
    
    var overlays = [];
      for (var i = 0; i < vertices.length; i++) {
        var overlay = new ol.Overlay({
          position: vertices[i],
          positioning: 'center-center',
          element: document.createElement('div'),
          stopEvent: false
        });
        overlay.getElement().innerHTML = (i + 1).toString();
        overlays.push(overlay);
      }
      for (var i = 0; i < overlays.length; i++) {
        map.addOverlay(overlays[i]);
       
      }
  }
  
</script>

<script>
  function specificAdjustFunction(){
    let vartexNo = document.getElementById('variableCoordinates').value -1;
    let area1Percent = document.getElementById('spercent1').value;
    let area2Percent = document.getElementById('spercent2').value;
    let c = vertices[vartexNo];
       let currentBigArea,currentSmallArea;
       if(firstPlotPercentAdj>secondPlotPercentAdj){
        currentBigArea = firstPlotPercentAdj;
        currentSmallArea = secondPlotPercentAdj;
       }
       else{
        currentBigArea = secondPlotPercentAdj;
        currentSmallArea = firstPlotPercentAdj;
       }

       let givenBigArea,givenSmallArea;
       if(area1Percent>area2Percent){
        givenBigArea = area1Percent;
        givenSmallArea = area2Percent;
       }
       else{
        givenBigArea = area2Percent;
        givenSmallArea = area1Percent;
       }
       let needBigAreaDecrement = currentBigArea- givenBigArea; // if minus result , big area will be incremented 
       let needSmallAreaIncrement = Math.abs(currentSmallArea-givenSmallArea); 
       console.log(needBigAreaDecrement , " " , needSmallAreaIncrement);
       autoDisplayArea(vertices);
   
         let rNode = c;
         let c1 = [rNode[0]+1,rNode[1]];
         vertices[vartexNo] = c1;
         NewLineSplitterDisplay(vertices);
         autoDisplayArea(vertices);
         console.log(firstPlotPercentAdj , " " , secondPlotPercentAdj);
         let c2 = [rNode[0],rNode[1]+1];
         vertices[vartexNo] = c2;
         NewLineSplitterDisplay(vertices);
         autoDisplayArea(vertices);
         console.log(firstPlotPercentAdj , " " , secondPlotPercentAdj);
         let c3 = [rNode[0]-1,rNode[1]];
         vertices[vartexNo] = c3;
         NewLineSplitterDisplay(vertices);
         autoDisplayArea(vertices);
         console.log(firstPlotPercentAdj , " " , secondPlotPercentAdj);
         let c4 = [rNode[0],rNode[1]-1];
         vertices[vartexNo] = c4;
         NewLineSplitterDisplay(vertices);
         autoDisplayArea(vertices);
         console.log(firstPlotPercentAdj , " " , secondPlotPercentAdj);
         let c5 = [rNode[0]+1,rNode[1]+1];
         vertices[vartexNo] = c5;
         NewLineSplitterDisplay(vertices);
         autoDisplayArea(vertices);
         console.log(firstPlotPercentAdj , " " , secondPlotPercentAdj);
         let c6 = [rNode[0]-1,rNode[1]-1];
         vertices[vartexNo] = c6;
         NewLineSplitterDisplay(vertices);
         autoDisplayArea(vertices);
         console.log(firstPlotPercentAdj , " " , secondPlotPercentAdj);
      

       

      
    
       
       vertices[vartexNo] = c1;
       NewLineSplitterDisplay(vertices);
       autoDisplayArea(vertices)
     
       vertices[vartexNo] = c2;
       NewLineSplitterDisplay(vertices);
       autoDisplayArea(vertices);
     
       vertices[vartexNo] = c3;
       NewLineSplitterDisplay(vertices);
       autoDisplayArea(vertices);
       
       vertices[vartexNo] = c4;
       NewLineSplitterDisplay(vertices);
       autoDisplayArea(vertices);
       
       vertices[vartexNo] = c5;
       NewLineSplitterDisplay(vertices);
       autoDisplayArea(vertices);
       
       
       NewLineSplitterDisplay(vertices);
       autoDisplayArea(vertices);
      

    
    
  }
</script>
<script>
  function NewLineSplitterDisplay(coordinatesSet){
    var newLineString = {
          "type": "LineString",
            "coordinates": coordinatesSet,
        }
        // console.log("The line String : ");
        // console.log(newLineString);
    var lineGeom  = new ol.format.GeoJSON().readGeometry(newLineString);
        map.addLayer(
            new ol.layer.Vector({
              source: new ol.source.Vector({
                features: [new ol.Feature(lineGeom)]
              }),
              style: new ol.style.Style({
                  stroke: new ol.style.Stroke({
                    color: 'black',
                    width: 1,
                    opacity:0.5
                  })
              })
     
            })
          );
  }
</script>
<script>
  
  function columnStore(arr,index){
    let carr = [];
    for(let i = 0;i<arr.length;i++){
      carr.push(arr[i][index]);
    }
    return carr;
  }

  function AreaIdentifyHorizontalSplit(ct1,ct2){
    let index = 1;
    let p1 = columnStore(ct1,index).sort();
    let p2 = columnStore(ct2,index).sort();
    if(p1[0]<p2[0]){
      upperIndex = 1;
      lowerIndex = 0;
    }
  }

  function AreaIdentifyVerticalSplit(ct1,ct2){
    let index  = 0;
    let p1 = columnStore(ct1,index).sort();
    let p2 = columnStore(ct2,index).sort();
    console.log(Math.max(...p1), " ",Math.max(...p2));
    let v1 = Math.max(...p1);
    let v2 = Math.max(...p2);
    if(v1>v2){
      leftIndex = 1;
      rightIndex = 0;
    }
    
  }

  function identifyDirection(){
    console.log(LineSplitterGeoJson)
    let l = JSON.parse(LineSplitterGeoJson).features[0].geometry.coordinates;
    console.log(l.length);
    if(l[0][1]>l[l.length-1][1]){
     
      return false;
    } // horizontal direction activated;
    else return true; // vertical direction activated;
    
  }

</script>
<!-- modal for adjust function  -->
<div class="modal fade" id="Adjust" tabindex="-1" role="dialog" aria-labelledby="exampleModalCenterTitle" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="exampleModalCenterTitle">Adjustment Operation : </h5>
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>
        <div class="modal-body">
          <table class="table">
            <tr>
              <td>First Splitted Plot</td>
              <td><input type="number" required id="spercent1" /></td>
              <td><span > %</span></td>
            </tr>
            <tr>
              <td>Second Splitted Plot </td>
              <td><input type="number" required id="spercent2"/></td>
              <td><span>%</span></td>
            </tr>
            <tr>
              <td>Changing Position of the Coordinates </td>
              <td>
                <input type="number" required id="variableCoordinates" />
              </td>
            </tr>
          </table>
        </div>
        <div class="modal-footer">
          <!-- <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button> -->
          <button type="submit" onclick="specificAdjustFunction()" class="btn btn-primary" data-dismiss="modal">Apply</button>
        </div>
    </div>
  </div>
</div>
<!-- Modal -->
<div class="modal fade" id="confirmSave" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel" aria-hidden="true">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="exampleModalLabel">Save Confirmation</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
          <b class="text-justify">Do you Want to Save the New Splitted  Plots ? </b>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
        <form action="/savePlot" method="post">
          <input type="hidden" id="spGeoJson_1" name="spGeoJson_1"/>
          <input type="hidden" id="spGeoJson_2" name="spGeoJson_2" />
          <input type="hidden"  name="plotId" value="<%=plotId %>" />
          <input type="hidden" name="sp_area_1" id="sp_area_1" />
          <input type="hidden" name="sp_area_2" id="sp_area_2" />
          <input type="hidden" name="sp_arm_1" id="sp_arm_1" value="1000"/>
          <input type="hidden" name="sp_arm_2" id="sp_arm_2" value="2000" />
          <button type="submit"  class="btn btn-primary m-1" data-mdb-dismiss="modal" >Save </button>
       </form>
        <!-- <button type="button" class="btn btn-primary">Save </button> -->
      </div>
    </div>
  </div>
</div>


<!-- Modal for N Equal Splitted polygon  -->
<!-- Button trigger modal -->


<!-- Modal -->
<div class="modal fade" id="NequalSplitPolygon" tabindex="-1" role="dialog" aria-labelledby="nEqualPolygon" aria-hidden="true">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="nEqualPolygon">Input Polygon Number </h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <input type="text" id="nDivision"  class="form-control" />
      </div>
      <div class="modal-footer">
        
        <button class="btn btn-success m-1"  data-dismiss="modal"  onclick="nDivisionLayer();"> Equal Split  </button> 
      </div>
    </div>
  </div>
</div>
  <div >
    <p align="center">Copyright © Business Automation Ltd. 2023</p>
  </div>
  </body>
</html>






